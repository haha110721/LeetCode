3Sum Closest (Medium)
===

Problem: https://leetcode.com/problems/3sum-closest/description/

---

1. Two Pointers (和 15. 3Sum 類似)
```python
# time: O(n²)，排序是 O(n log n)，雙層迴圈是 O(n²)
# space: O(1)，只用了常數變數

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        closest = float('inf')  # 回傳答案，初始化為無限大

        for i in range(len(nums) - 2):  # 固定第一個數字
            left, right = i + 1, len(nums) - 1  # 左右指針

            while left < right:
                current_sum = nums[i] + nums[left] + nums[right]

                # 若剛好等於 target，就直接回傳
                if current_sum == target:
                    return current_sum
                
                # 更新最接近的和
                if abs(current_sum - target) < abs(closest - target):
                    closest = current_sum

                # 移動指針
                if current_sum < target:
                    left += 1
                else:
                    right -= 1
        
        return closest
```

2. (XX: TLE) backtrack
```python
# time: 我一開始想到用 backtrack，但是時間複雜度太高 (O(n³)，會列舉出所有長度為 3 的組合（甚至可能多餘剪枝邏輯），效能會很差)

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        self.closest = float('inf')

        def backtrack(start, path):
            if len(path) == 3:
                total = sum(path)
                if abs(total - target) < abs(self.closest - target):
                    self.closest = total

                return  # 表示這一條 path 已經完成了，不需要繼續選下去。已經選了 3 個數就應該要計算它的總和、更新最接近的結果，然後就「回頭」了，不要再繼續選第四個數
        
            for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(i + 1, path)
                path.pop()

        backtrack(0, [])
        return self.closest
```
